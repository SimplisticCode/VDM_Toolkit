module Clocks
exports all
definitions
/*********************************************************************************
 *
 *	Copyright (c) 2017-2022, INTO-CPS Association,
 *	c/o Professor Peter Gorm Larsen, Department of Engineering
 *	Finlandsgade 22, 8200 Aarhus N.
 *
 *	MIT Licence:
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy of
 *	this software and associated documentation files (the "Software"), to deal in
 *	the Software without restriction, including without limitation the rights to use,
 *	copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 *	Software, and to permit persons to whom the Software is furnished to do so,
 *	subject to the following conditions:
 *
 *	The above copyright notice and this permission notice shall be included in all
 *	copies or substantial portions of the Software.
 *
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 *	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 *	PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 *	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *	OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 *	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *	SPDX-License-Identifier: MIT
 *
 *********************************************************************************/
 types

	--@LF percolating this through wherever real >=0 iss needed makes for simpler  expansions/proofs. 
	Real1 = real
	inv r == r >=0 ;

	/**
	 * A point in superdense time is represented by a real quantity and a whole
	 * number instant "within" that time.
	 */
	Time ::
		r	: Real1
		i	: nat
	eq a = b == a.r = b.r and a.i = b.i
	ord a < b ==
		(a.r < b.r) or (a.r = b.r and a.i < b.i); 
		
	/**
	 * Possible "interval" values for a Clock variable
	 */
	Interval = <constant> | <fixed> | <calculated> | <tunable> | <changing> | <countdown> | <triggered>;

	FMUMode = <INIT> | <DONE> | <STEP> | <EVENT>;

	Contract = <none> | <reactive> | <delayed> ;

	RealNaN = real | <NaN>;

	PortType = <discrete> | <continous>; 

	Causality = <input> | <output>;
	/**
	 * The different types of actions
	 */
	ActionType = <get> | <set> | <step> | <getC> | <setC> ;  

	ValueType = real | int | bool;

	--@LF declaration before use
	/**
	 * A convenient way to name FMUs.
	 */
	Name = seq1 of char;

	/**
	 * A variable or clock reference. These are unique within an FMU.
	 */
	Ref = nat;

	/*
		An FMU action has a type and some infomration describe the paramters of the actions
	*/
	Action ::
		actionType : ActionType
		fmu : Name
		port : Ref
	inv mk_Action(actionType, -, port) ==
		actionType = <step> <=> port <> 0
	eq act1 = act2 == 
		act1.actionType = act2.actionType 
		and act1.fmu = act2.fmu 
		and act1.port = act2.port
	ord a < b == a.port < b.port
		or (a.port = b.port and len(a.fmu) < len(b.fmu));
	


	/**
	* A reference to a connection point in a specific named FMU.
	*/
	FMURef ::
		name	: Name
		ref		: Ref
	eq mk_FMURef(name1, ref1) = mk_FMURef(name2, ref2) == 
		name1 = name2
		and ref1 = ref2
	ord a < b == a.ref < b.ref;

	/**
	* The value that a clock or variable can have. 
	* It contains a time and a value
	*/
	FMIValue ::
		fmiValue : ValueType
		time 	 : Time
	eq mk_FMIValue(val1, t1) = mk_FMIValue(val2, t2) == 
		val1 = val2
		and t1 = t2
	ord mk_FMIValue(-, t1) < mk_FMIValue(-, t2) == t1 < t2;

	/**
	* The current known FMU variable values. These are usually used by FMUs, but note that
	* Clocks can produce temporary environments that are not committed until a step.
	*/
	Environment = map Ref to FMIValue;

	/**
	* An Equation is used to modify the values of an FMU in order to compute a new
	* step in time. A clock defines a set of equations to activate.
	*/
	Equation = Environment -> Environment;


	/**
	* A variable is identified by a Ref (within an FMU).
	*/
	Variable ::
		name 		: Name
		ref			: Ref
		time        : Time
		causality	: Causality
		type		: PortType
		clocks		: set of Ref -- clocks that the variable can active
		dependsOn   : set of Ref -- feedthrough only relevant for outputs
		contract    : Contract 
	inv mk_Variable(-, -, -, causality, type, clocks, dependsOn, contract) ==
		(causality = <output> => contract = <none>) -- input contract only relevant for inputs
		and (causality = <input> => contract <> <none>) -- input contract defined on inputs
		and (causality = <input> => dependsOn = {})
		and (type = <continous> => clocks = {})
		and ((type = <discrete> and causality = <input>)  => clocks = {})
	eq  mk_Variable(name1, ref1, -, causality1, -, -, -, -) 
		=  mk_Variable(name2, ref2, -, causality2, -, -, -, -) ==
		name1 = name2 and ref1 = ref2 and causality1 = causality2
	ord mk_Variable(name1, ref1, -, -, -, -, -, -) 
		<  mk_Variable(name2, ref2, -, -, -, -, -, -) ==
		ref1 < ref2 or (ref1 = ref2 and len(name1) < len(name2));


	TimeBasedClock ::
		name		: Name
		shift 		: Real1
		period		: Real1
		interval	: Interval
		master 		: FMURef -- who should ask about the clock schedule
	inv clock == clock.interval <> <triggered>;


	/**
	* A clock is identified by a Ref (within an FMU) and activates a set of equations.
	*/
	Clock ::
		name 		: Name 
		ref			: Ref
		type		: Causality
		interval	: Interval
		dependsOn 	: set of Ref -- The clocks that can trigger an clock
		equations	: set of Ref -- variables the clock activates
	inv clock ==
		(clock.type = <output> => clock.interval = <triggered>)	-- An output clock must be of type triggered 
		and (clock.type = <input> => clock.dependsOn = {})  -- Only output clocks are subject to feedthrough
	eq mk_Clock(name1, ref1, type1, interval1, -, -) = mk_Clock(name2, ref2, type2, interval2, -, -) == 
		name1 = name2 and ref1 = ref2 and type1 = type2 and interval1 = interval2
	ord c1 < c2 == c1.ref < c2.ref;


functions
	--@LF this is just like your let, but look at the pre/post! 
	clock_refs: set of Clock -> set of Ref 
	clock_refs(cs) == { c.ref | c in set cs }
	pre 
		true
	post
		card cs = card RESULT;


	var_refs: set1 of Variable -> set1 of Ref
	var_refs(vs) == { v.ref | v in set vs }
	pre 
		true
	post
		card vs = card RESULT; 


  --@doc Fold (iterate, accumulate, reduce) a binary function over a sequence.
  --     The function is assumed to be associative and have an identity element.
  fold[@T]: (@T * @T -> @T) * @T * seq of @T +> @T
  fold(f, e, s) == 
  	if s = [] then
  		e
  	else if len s = 1 then
  		hd s
  	else
  		let lens: nat1 = len s in
	  		f(fold[@T](f,e,s(1,...,lens div 2)), fold[@T](f,e,s((lens div 2)+1,...,lens)))
  --@doc pre not possible to refer to @T
  --pre (exists x:@T & forall y:@T & f(x,y) = y and f(y,x) = y)
  --and forall x,y,z:@T & f(x,f(y,z)) = f(f(x,y),z)
  measure 
  	len s;

  --@doc Fold (iterate, accumulate, reduce) a binary function over a non-empty sequence.
  --     The function is assumed to be associative.
  fold1[@T]: (@T * @T -> @T) * seq1 of @T +> @T
  fold1(f, s) == 
  	if len s = 1 then
  		hd s
  	else
  		let lens: nat1 = len s in
  			f(fold1[@T](f,s(1,...,lens div 2)), fold1[@T](f,s((lens div 2)+1,...,lens)))
  --pre forall x,y,z:@T & f(x,f(y,z)) = f(f(x,y),z)
  pre 
  	true
  measure 
  	len s;

	maxxs[@T]: seq1 of @T * (@T * @T -> @T) -> @T
  	maxxs(s,lt_ord) == 
  		fold1[@T](lt_ord,s)
	pre pre_fold1[@T](lt_ord, s)
	post 
		RESULT in set elems s and forall e in set elems s & lt_ord(RESULT,e) = RESULT or RESULT = e;
		
types

	IOLeo ::
		--@LF these are reserved wrods I think
		LFinput				: set of Variable	-- Um 
		LFoutput            : set of Variable   -- Ym
	inv mk_IOLeo(LFinput, LFoutput) == LFinput union LFoutput <> {};

	
	FMU :: 
		id 					: nat
		name				: Name				-- m
		--@LF is there any ooportunity to make any of these a type like Real1 for the structured types themselves? 
		clocks				: set of Clock		-- Ucm + Ycm
		io 					: IOLeo
		mode				: FMUMode -- Mode of the FMU
		time				: Time				-- time is per FMU
		stepped				: bool 				-- Has the FMU been stepped
		maxStep             : Real1				-- How far can the FMU step
		env					: Environment
		activeClocks		: set of Ref		-- 
		activeEquations		: set of Equation	-- I think this needs to be a set of reference
	inv mk_FMU(-, -, clocks, io, mode, time, -, -, env, activeClocks, activeEquations) ==
		let vars  : set1 of Variable = io.LFinput union io.LFoutput 
		in
			pre_var_refs(vars) and pre_clock_refs(clocks)
		and 
		let
			crefs : set of Ref  = clock_refs(clocks), --@LF now you have the postcondition
			vrefs : set1 of Ref  = var_refs(vars), --@LF now you have the set1 pre on var_refs 
			refs  : set1 of Ref = crefs union vrefs --@LF if you wanted to tolerate shared refs... "\ (crefs inter vrefs)"" 
		in
			--@LF these explicit posts can be sometimes spurious/unnecessary, but they also shield against changes 
			post_clock_refs(clocks, crefs) and post_var_refs(vars, vrefs) and 
			-- All clock and variable references are unique
			crefs inter vrefs = {} 
			--@ST missing "the" over map here 
			and
			card refs = card clocks + card vars --@LF this will be a consequence (i.e. possibly unnecessary here)
			-- All references in the environment are defined
			and (dom env subset refs)
			-- All active clocks are defined
			and (activeClocks subset crefs)
			-- A clock can only be active when the fmu is in event mode
			--@LF whether a single => or three won't make much of a difference to Isabelle 
			and (mode <> <EVENT> => activeClocks = {} and activeEquations = {} and time.i = 0)
			-- An equation can only be active when the fmu is in event mode
			and (mode <> <EVENT> => activeEquations = {})
			-- The integer clock can only be nonzero in event mode
			and (mode <> <EVENT> => time.i = 0)
			-- All variables' clocks are defined
			and (forall var in set vars & var.clocks subset crefs)
			-- An active variable is active by a clock Todo
			--and (forall (cref |-> val) in set activeEquations 
			---		& exists c in set clocks & c.ref in set activeClocks and equation in set c.equations)
			-- All scheduled clocks are defined
		--@LF given the specificity of orderness, you must add a specificity of equality
		eq fmu1 = fmu2 == fmu1.id = fmu2.id
		--@LF given that the FMU1/2 projections are just single case, won't bother with the mk_FMU expression 
		ord fmu1 < fmu2 == fmu1.id < fmu2.id
		;

functions
	/**
	* Dereference a clock in a given FMU.
	*/
	derefClock: FMU * Ref -> Clock
	derefClock(fmu, ref) ==
		iota c in set fmu.clocks & c.ref = ref
	pre exists c in set fmu.clocks & c.ref = ref;

	/**
	* Dereference an input in a given FMU.
	*/
	derefInput: FMU * Ref -> Variable
	derefInput(fmu, ref) ==
		iota c in set fmu.io.LFinput & c.ref = ref
	pre exists c in set fmu.io.LFinput & c.ref = ref;

	/**
	* Dereference an output in a given FMU.
	*/
	derefOutput: FMU * Ref -> Variable
	derefOutput(fmu, ref) ==
		iota c in set fmu.io.LFoutput & c.ref = ref
	pre exists c in set fmu.io.LFoutput & c.ref = ref;

types

Connections = map FMURef to FMURef
	inv cons ==
		rng cons inter dom cons = {};

ScenarioConnections ::
		dataConnections			: Connections
		clockConnections		: Connections
		timedClockConnections	: map Name to set1 of FMURef
	inv mk_ScenarioConnections(connections, clockConnections, timedClockConnections) ==
		dom clockConnections inter dom connections = {}
		and rng clockConnections inter rng connections = {}
		and rng clockConnections inter dunion rng timedClockConnections = {}
		and rng connections inter dunion rng timedClockConnections = {};


-- 	/**
-- 	* A machine is a collection of FMUs, plus a connection map between them. The connection
-- 	* sources must be FMU outputs and the destinations must be FMU inputs.
-- 	*/
	Scenario ::
		fmus					: map Name to FMU
		timeBasedClocks 		: set of TimeBasedClock
		connections 			: ScenarioConnections
	inv mk_Scenario(fmus, timeBasedClocks, connections) ==
		(forall srcRef in set dom connections.dataConnections &
			-- Every connection's source is a known FMU
			srcRef.name in set dom fmus
			-- Every connection's source is an output from its FMU
			and 
			let srcFMU : FMU = fmus(srcRef.name),
				trgRef : FMURef = connections.dataConnections(srcRef) in 
				-- Every connection's destination is an input of its FMU
				(exists v in set srcFMU.io.LFoutput & srcRef.ref = v.ref)
				-- Every connection's destination is a known FMU
				and trgRef.name in set dom fmus
				and let trgFMU = fmus(trgRef.name) in 
					(exists v in set trgFMU.io.LFinput & trgRef.ref = v.ref)
				and
				--@LF exu warning 11151 entail a potential failure in the call to deferOutput, which
				--		  migh mean a failed pre with some of Scenario's parameters 
				 pre_derefOutput(srcFMU, srcRef.ref) 
				and pre_derefInput(trgFMU, trgRef.ref)
				and 
				let outputVar : Variable = derefOutput(srcFMU, srcRef.ref),
					inputVar : Variable = derefInput(trgFMU, trgRef.ref) in
				outputVar.type = inputVar.type
		)
		and
		(forall fmuref in set dom connections.clockConnections &
			-- Every connection's source is a known FMU
			fmuref.name in set dom fmus
			-- Every connection's source is an output from its FMU
			and let fmu : FMU = fmus(fmuref.name) in
				exists v in set fmu.clocks & fmuref.ref = v.ref and v.type = <output> and v.interval = <triggered>)
		and
		(forall fmuref in set rng connections.clockConnections &
			-- Every connection's destination is a known FMU
			fmuref.name in set dom fmus
			-- Every connection's destination is an input of its FMU
			and let fmu : FMU = fmus(fmuref.name) in
				exists v in set fmu.clocks & fmuref.ref = v.ref and v.type = <input> and v.interval = <triggered>)
		and dom connections.timedClockConnections = {c.name | c in set timeBasedClocks}
		and forall t in set timeBasedClocks & t.master in set connections.timedClockConnections(t.name)
		and forall c in set dunion {c | c in set rng connections.timedClockConnections} &
																				pre_derefClock(fmus(c.name),c.ref)
																				and 
																				let clock = derefClock(fmus(c.name),c.ref) in
																				clock.interval <> <triggered> and clock.type = <input>;	
functions
	/**
	* These functions are total, because the error conditions that you would expect
	* on an API are modelled by preconditions or type invariants.
	*/

	/*
		The preconditions of the actions from the paper - notice that the actions are only valid when the FMUs are not in the done state
	*/
	preSet: FMU * Ref -> bool
	preSet(fmu, input)==
		exists1 v in set fmu.io.LFinput & v.ref = input and v.causality = <input>
			and fmu.mode <> <DONE>
			and (fmu.mode = <STEP> => v.type = <continous>)
			and (fmu.mode = <EVENT> => v.type = <discrete>)
		pre true;
	

	set_m: FMU * Ref * FMIValue +> FMU
	set_m(fmu, ref, val) ==
		mu(fmu, env |-> fmu.env ++ { ref |-> val })
		-- and calculate equations?
	pre pre_preSet(fmu, ref) and preSet(fmu, ref)
	post RESULT.mode = fmu.mode
	and RESULT.time = fmu.time
	and RESULT.io.LFinput = fmu.io.LFinput;

	feedthroughSatisfied : FMU * Variable -> bool
	feedthroughSatisfied(fmu, outputVariable)==
		let inputs : set of Variable = {input | input in set fmu.io.LFinput & input.ref in set outputVariable.dependsOn} in
		(forall i in set inputs &
				i.ref in set dom fmu.env
				and (i.contract = <reactive> => fmu.env(i.ref).time >= fmu.time)
				and (i.contract = <delayed> => fmu.env(i.ref).time = fmu.time))
		pre true;

	preGet: FMU * Ref -> bool
	preGet(fmu, ref)==
		let outputVariable : Variable = derefOutput(fmu, ref) in
		(exists1 v in set fmu.io.LFoutput & v.ref = ref and v.causality = <output>)
			and fmu.mode <> <DONE>
			---@ST is this needed?
			and pre_feedthroughSatisfied(fmu, outputVariable)
			and feedthroughSatisfied(fmu, outputVariable)
	pre pre_derefOutput(fmu, ref);


	get_m: FMU * Ref +> FMU * FMIValue
	get_m(fmu, ref) ==
		-- calculate equations?
		mk_(fmu, fmu.env(ref))
	pre preGet(fmu, ref) and pre_preGet(fmu, ref);


	preSetC: FMU * Ref * bool -> bool
	preSetC(fmu, clock, val)==
	 	(exists1 v in set fmu.clocks & v.ref = clock and v.type = <input>)
			and val <=> not clock in set fmu.activeClocks -- We can only activate a clock that 
            and fmu.mode = <EVENT>
		pre true;

	set_cm: FMU * Ref * bool +> FMU
	set_cm(fmu, ref, val) ==
		mu(fmu,
			env				|-> fmu.env ++ {ref |-> mk_FMIValue(val, fmu.time)},
			activeClocks	|-> if val then fmu.activeClocks union {ref} else fmu.activeClocks \ {ref})
	pre preSetC(fmu, ref, val) and pre_preSetC(fmu, ref, val)
	post val <=> ref in set RESULT.activeClocks;

	preGetC: FMU * Ref -> bool
	preGetC(fmu, clock)==
	 	(exists1 v in set fmu.clocks & v.ref = clock and v.type = <output>)
		 and fmu.mode = <EVENT> -- We can only get an output clock
		pre true;

	get_cm: FMU * Ref +> FMU * FMIValue
	get_cm(fmu, ref) ==
		mk_(fmu, fmu.env(ref))
	pre preGetC(fmu, ref) and pre_preGetC(fmu,ref);


	preStepT: FMU * Real1 -> bool
	preStepT(fmu, stepSize)==
		let continousInputs : set of Variable = {i | i in set fmu.io.LFinput & i.type = <continous>} in
		(forall i in set continousInputs &
			 		(i.contract = <reactive> => fmu.env(i.ref).time.r = fmu.time.r + stepSize)
					and (i.contract = <delayed> => fmu.env(i.ref).time = fmu.time))
			and fmu.mode = <STEP>
		pre true;


	postStepT : FMU * Real1 * bool * FMU * Real1 -> bool
	postStepT(fmu, stepTaken, eventTriggered, oldFMU, stepAsked) ==
		stepTaken <= stepAsked -- We cannot take a step larger than what the Importer requested
        and stepTaken <= oldFMU.maxStep -- We cannot take a step larger than what the FMU is capable of
		and eventTriggered <=> (oldFMU.maxStep <= stepTaken)
		and fmu.time.r = oldFMU.time.r + stepTaken
		and fmu.time.i = oldFMU.time.i
	pre true;
	
	calculate : Ref * Environment * Time -> FMIValue 
	calculate(ref, env, time) ==
		-- env: map S to T 
		-- T :: x : X, y: Y
		-- mk_FMIValue(real ! bool ! nat ... , Time)
		mk_FMIValue(env(ref).fmiValue, time)
	pre ref in set dom env;


	/*
	* This function updates the value at the outputs
	*/
	updateOutputs : FMU * Time -> Environment
	updateOutputs(fmu, time) ==
		let outputRef : set of Ref = {outputVar.ref | outputVar in set fmu.io.LFoutput} in
			{oValue |-> calculate(oValue, fmu.env, time) | oValue in set dom fmu.env inter outputRef & pre_calculate(oValue, fmu.env, time)}
	pre true;
	

	step_tm: FMU * Real1 +> FMU * Real1 * bool
	step_tm(fmu, step) ==
		let mk_(stepTaken, eventTriggered) : Real1 * bool = 
			if step >= fmu.maxStep then mk_(fmu.maxStep, true) else mk_(step, false),
		
			newTime = mk_Time(fmu.time.r + stepTaken, fmu.time.i),
			updatedFMU = mu(fmu, 
								time |-> newTime,
								env |-> updateOutputs(fmu, newTime),
								stepped |-> true
							)
		in
		mk_(updatedFMU, stepTaken, eventTriggered)
	pre 
		preStepT(fmu, step) 
		and pre_preStepT(fmu, step)
		and 
			let mk_(stepTaken, eventTriggered) : Real1 * bool = 
					if step >= fmu.maxStep then mk_(fmu.maxStep, true) else mk_(step, false),
				newTime = mk_Time(fmu.time.r + stepTaken, fmu.time.i)
			in
				pre_updateOutputs(fmu, newTime)
	post 
		pre_postStepT(RESULT.#1, RESULT.#2, RESULT.#3, fmu, step) 
		and postStepT(RESULT.#1, RESULT.#2, RESULT.#3, fmu, step);
		
	
	preStepE: FMU -> bool
	preStepE(fmu)==
		fmu.mode = <EVENT>
	pre true;

	postStepE: FMU * FMU * bool -> bool
	postStepE(fmu, oldFMU, -)==
		fmu.mode = <EVENT> 		-- FMU remains in event mode - it always does the Importer should bring it out
        and fmu.time.i = oldFMU.time.i + 1 -- The Integer component of the FMU should be increased
		and fmu.time.r = oldFMU.time.r
		and fmu.activeClocks = {} -- All clocks get disabled when we step the FMU
	pre true;

	step_e: FMU +> FMU * bool
	step_e(fmu) ==
	let updatedFMU : FMU = mu(
								fmu, 
							    time |-> mk_Time(fmu.time.r, fmu.time.i + 1),
								activeClocks |-> {}
							) 
		in
		mk_(updatedFMU, false) -- We never trigger a state event 
	pre preStepE(fmu) and pre_preStepE(fmu)
	post pre_postStepE(RESULT.#1, fmu, RESULT.#2) and postStepE(RESULT.#1, fmu, RESULT.#2);
	

	/*
	* 
	*/
	next_tm: FMU * Ref +> RealNaN
	next_tm(fmu, ref) ==
		is not yet specified
	pre exists v in set fmu.clocks & v.ref = ref and v.type = <input>
		and v.interval in set { <tunable>, <changing>, <countdown> };


	createFMURefs: FMU * set of Ref -> set of FMURef
	createFMURefs(fmu, clocks) ==
		{ mk_FMURef(fmu.name, clock) | clock in set clocks }
	pre true
	post card RESULT = card clocks;



types

	ClocksImporter ::
		activeClocks : set of FMURef -- active clocks
		readyClocks : set of FMURef -- clocks that can be activated
		inactiveClocks : set of FMURef -- inactive clocks
		relevantOutputClocks : set of FMURef -- All Output clocks the Importer must query since their state can have changed
		relevantInputClocks  : set of FMURef -- All Input clocks the Importer must update because their output changed 
	inv mk_ClocksImporter(activeClocks, readyClocks, inactiveClocks, relevantInputClocks, relevantOutputClocks) ==
		activeClocks inter readyClocks = {}
		and inactiveClocks inter activeClocks = {}
		and inactiveClocks inter readyClocks = {}
		and relevantInputClocks inter relevantOutputClocks = {};


	-- EventInformation ::
	-- 	clocks 			: ClocksImporter 
	-- 	fmusWithEvent	: set of Name -- FMUs that triggered a state event

	-- 	activeEquations : set of FMURef -- All active equations 
	-- 	calculatedEquations : set of FMURef -- The equations the Importer has calculated
	-- 	readyEquations : set of FMURef -- The equations that can be activated
	-- inv mk_EventInformation(fmusWithEvent, relevantOutputClocks, relevantInputClocks, activeEquations, calculatedEquations, readyEquations) ==


	functions 
	ClocksByType : FMU * Causality -> set of Ref
	ClocksByType(fmu, type)	==
		{clock.ref | clock in set fmu.clocks & clock.type = type }
	pre true;

	types

	/*
		The Importer runs the simulation
		It keeps track of the input and output to adapt to the behavior of the scenario
		It has a simulation time and values to exchange between the FMUs
	*/
	Importer :: 
		scenario : Scenario
        schedule : map Name to Real1 -- the time the clock should tick
		activeClocks : set of FMURef -- active clocks
		readyClocks : set of FMURef -- clocks that can be activated
		inactiveClocks : set of FMURef -- inactive clocks
		fmusWithEvent	: set of Name -- FMUs that triggered a state event
		relevantOutputClocks : set of FMURef -- All Output clocks the Importer must query since their state can have changed
		relevantInputClocks  : set of FMURef -- All Input clocks the Importer must update because their output changed 
		activeEquations : set of FMURef -- All active equations 
		calculatedEquations : set of FMURef -- The equations the Importer has calculated
		readyEquations : set of FMURef -- The equations that can be activated
		time : Time -- Simulation Time
		endtime : Time
		stepSize : Real1 -- Planned step size
		valueMap : map FMURef to FMIValue
	inv imp ==
		let fmus = imp.scenario.fmus in
		let inputclocks = 
			dunion {createFMURefs(fmu, ClocksByType(fmu, <input>)) 
					| 
					fmu in set rng fmus 
						& pre_ClocksByType(fmu, <input>)
						and pre_createFMURefs(fmu, ClocksByType(fmu, <input>)) 
					} in
		let outputclocks = 
			dunion {createFMURefs(fmu, ClocksByType(fmu, <output>)) 
					| fmu in set rng fmus 
						& pre_ClocksByType(fmu, <output>)
						and pre_createFMURefs(fmu, ClocksByType(fmu, <output>))
				} in
		let clocks = inputclocks union outputclocks
		in
		--imp.activeClocks union imp.inactiveClocks = clocks  -- a clock is either inactive or active
		card (imp.activeClocks union imp.inactiveClocks) = card clocks
		and imp.activeClocks inter imp.inactiveClocks = {} -- a clock cannot be active and inactive
		and imp.activeClocks inter imp.readyClocks = {} -- an active clock can not be ready
		and imp.activeClocks = dunion {createFMURefs(fmu, fmu.activeClocks) | fmu in set rng fmus }
		and imp.fmusWithEvent subset dom fmus -- all fmus that wishes to enter event mode is in the scenario
		and imp.relevantInputClocks subset inputclocks -- a relevant input clock needs to be an input clock
		and imp.relevantOutputClocks subset outputclocks -- a relevant output clock needs to be an output clock
		and imp.relevantInputClocks inter imp.relevantOutputClocks = {}
		--and imp.activeEquations = dunion {fmu.activeEquations | fmu in set rng fmus} -- Equations are actived by the clocks
		--and dom imp.schedule = dunion {createFMURefs(fmu, {clock.ref | clock in set fmu.clocks & clock.type = <input> and clock.interval <> <triggered>}) | fmu in set rng fmus }-- We only have time based clocks in the schedule
		---and imp.activeEquations = {c.equations | c in set clocks & c.ref in set imp.activeClocks} -- Invariant for the paper TYPE MISMATCH
		and imp.endtime >= imp.time -- The simulation cannot not proceed once the endtime is reached
		and imp.activeEquations inter imp.readyEquations = {}
		and imp.readyEquations inter imp.calculatedEquations = {}
		;


functions

	/*
	* This function updates the Importer's environment according to observed clock value
	*/
	updateEnvironmentClock : Importer * FMU * Ref * bool -> Importer
	updateEnvironmentClock(I, fmu, clock, val)==
		let fmuref : FMURef = mk_FMURef(fmu.name, clock),
			activatedVariables : set of FMURef = createFMURefs(fmu, dunion {c.equations | c in set fmu.clocks & clock = c.ref}) in
		mu(I,
			scenario |-> mu(I.scenario, fmus |-> I.scenario.fmus ++ {fmu.name |-> fmu}),
			activeClocks |-> if val then I.activeClocks union {fmuref} else I.activeClocks \ {fmuref},
			readyClocks |-> if val then I.readyClocks \ {fmuref} else I.readyClocks,
			inactiveClocks |-> if val then I.inactiveClocks \ {fmuref} else I.inactiveClocks union {fmuref},
			activeEquations |-> if val then I.activeEquations union activatedVariables else I.activeEquations \ activatedVariables,
			readyEquations |-> if val then I.readyEquations \ activatedVariables else I.readyEquations
		)
	pre true
	post let fmuRef : FMURef = mk_FMURef(fmu.name, clock) in
		pre_createFMURefs(fmu, dunion {c.equations | c in set fmu.clocks & clock = c.ref})
	and
	(val => (I.activeClocks subset RESULT.activeClocks
			and RESULT.readyClocks psubset I.readyClocks
			and RESULT.inactiveClocks psubset I.inactiveClocks
			and fmuRef in set RESULT.activeClocks))
	and
	(not val => (fmuRef in set RESULT.inactiveClocks));


    /*
        This function ensures that the two sets contain the same FMUs
     */
    sameSetOfFMUs : set of FMU * set of FMU -> bool
    sameSetOfFMUs(fmus1, fmus2)==
    -- The old and new FMUs should contain the same set of FMUs
            card fmus1 = card fmus2
                and {m.name | m in set fmus1} = {m.name | m in set fmus2}
		pre true;

	fmusNotAffected : set of FMU * set of FMU -> bool
	fmusNotAffected(oldFMUs, newFMUs) == oldFMUs = newFMUs
	pre sameSetOfFMUs(oldFMUs, newFMUs) and pre_sameSetOfFMUs(oldFMUs, newFMUs);

	updateEnvironmentEquation : Importer * FMU * FMURef -> Importer
	updateEnvironmentEquation(I, fmu, equation)==
		let triggeredClocks : set of Clock = {clock | clock in set fmu.clocks & equation.ref in set clock.dependsOn} in
		-- We need to check if we triggered any clocks by setting the variable
		let triggeredInputs : set of FMURef = {mk_FMURef(equation.name, inputClock.ref) | inputClock in set triggeredClocks & inputClock.type <> <input> },
			triggeredOutputs : set of FMURef = {mk_FMURef(equation.name, outputClock.ref)  | outputClock in set triggeredClocks & outputClock.type <> <output> } in
		mu(I, 
			scenario |-> mu(I.scenario, fmus |-> I.scenario.fmus ++ {fmu.name |-> fmu}),
			calculatedEquations |-> I.calculatedEquations union {equation}, 
			relevantInputClocks |-> I.relevantInputClocks union triggeredInputs,
			relevantOutputClocks |-> I.relevantOutputClocks union triggeredOutputs
		)
	pre equation in set I.activeEquations \ I.calculatedEquations
		and fmu.mode =  <EVENT>
	post equation in set RESULT.calculatedEquations
		and I.relevantInputClocks subset RESULT.relevantInputClocks
		and I.relevantOutputClocks subset RESULT.relevantOutputClocks
		and
		let resultFMUs = rng ({fmu.name} <-: RESULT.scenario.fmus),
			oldFMUs = rng ({fmu.name} <-: I.scenario.fmus) in
			pre_fmusNotAffected(oldFMUs, resultFMUs)
			and fmusNotAffected(oldFMUs, resultFMUs);



	/*
		The preconditions of the actions from the Importer's perspective
        The Importer can look at the global state of the simulation to ensure synchronization between the FMUs
        But it does also ensure that the precondition of the action is satisfied
	*/
	preSetI: Importer * FMU * Ref -> bool
	preSetI(I, fmu, port)==
		let inputVar : Variable = derefInput(fmu, port),
			fmuRef : FMURef = mk_FMURef(fmu.name, port) in
		(fmu.mode = <EVENT> <=> fmuRef in set (I.activeEquations \ I.calculatedEquations) and inputVar.type = <discrete>)
		and fmuRef in set dom I.valueMap
		and	let val : FMIValue = I.valueMap(fmuRef) in 
		 (fmu.mode = <STEP> => (inputVar.type = <continous> and (inputVar.contract = <reactive> => val.time > fmu.time) 
		 												 	and (inputVar.contract = <delayed> => val.time = fmu.time))
		)
		and preSet(fmu, port) 
	pre pre_derefInput(fmu, port) and pre_preSet(fmu, port);


	-- This action obtains a value and set it on an input		
	setPort : Importer * FMURef -> Importer
	setPort(I, port)==
		let fmi_value = I.valueMap(port) in
			let fmu = set_m(I.scenario.fmus(port.name), port.ref, fmi_value) in 
				mu(I,
					scenario |-> mu(I.scenario, fmus |-> I.scenario.fmus ++ {fmu.name |-> fmu}), 
					valueMap |-> {port} <-: I.valueMap
				)
	pre pre_preSetI(I, I.scenario.fmus(port.name), port.ref) 
		and preSetI(I, I.scenario.fmus(port.name), port.ref) 
		and port in set dom I.valueMap
		and pre_set_m(I.scenario.fmus(port.name), port.ref, I.valueMap(port)) 
	post
		let oldFMUs = rng ({port.name} <-: I.scenario.fmus),
			resultFMUs = rng ({port.name} <-: RESULT.scenario.fmus) in
		pre_fmusNotAffected(oldFMUs, resultFMUs)
		and fmusNotAffected(oldFMUs, resultFMUs)
		and (card dom RESULT.valueMap + 1) = card dom I.valueMap;

	/*
	* Calculates an input equation that needs to be calculated
	* The port is calculated by the setting its value
	*/
	calculateInput : Importer * FMURef -> Importer
	calculateInput(I, equation)==
		-- @Printf("Calculating  input equation : %s\n", equation)
		let I1 : Importer = setPort(I, equation) in
			updateEnvironmentEquation(I1, I.scenario.fmus(equation.name), equation)
	pre 
		equation.name in set dom I.scenario.fmus
		and pre_setPort(I, equation)
		and pre_updateEnvironmentEquation(setPort(I, equation), I.scenario.fmus(equation.name), equation)
		and
		let fmu : FMU = I.scenario.fmus(equation.name) in
			equation in set I.activeEquations \ I.calculatedEquations -- The value should be active and not calculated before
			and fmu.mode = <EVENT>
			and pre_preSetI(I, fmu, equation.ref)
			and preSetI(I, fmu, equation.ref)
	post
	let newFMU : FMU = RESULT.scenario.fmus(equation.name),
		oldFMU : FMU = I.scenario.fmus(equation.name) 
	in
		newFMU.mode = oldFMU.mode
		and newFMU.time = oldFMU.time
		and newFMU.io.LFoutput = oldFMU.io.LFoutput
		and pre_fmusNotAffected(rng ({equation.name} <-: I.scenario.fmus), rng ({equation.name} <-: RESULT.scenario.fmus))
		and fmusNotAffected(rng ({equation.name} <-: I.scenario.fmus), rng ({equation.name} <-: RESULT.scenario.fmus))
		and equation in set RESULT.calculatedEquations;


	preGetI: Importer * FMU * Ref -> bool
	preGetI(I, fmu, port)==
		let outputVar : Variable = derefOutput(fmu, port),
			fmuRef : FMURef = mk_FMURef(fmu.name, port),
			connectedInput : FMURef = I.scenario.connections.dataConnections(fmuRef) in
			let input : Variable = derefInput(I.scenario.fmus(connectedInput.name), connectedInput.ref) in
		(fmu.mode = <EVENT> <=> fmuRef in set (I.activeEquations \ I.calculatedEquations) and outputVar.type = <discrete>)
		and (fmu.mode = <STEP> => (outputVar.type = <continous> and (input.contract = <delayed> => fmu.stepped)))
		and preGet(fmu, port)
		and connectedInput not in set dom I.valueMap
	pre pre_preGet(fmu, port) 
		and pre_derefOutput(fmu, port)
		and 
		let fmuRef : FMURef =  mk_FMURef(fmu.name, port),
			connectedInput : FMURef = I.scenario.connections.dataConnections(fmuRef) in
				fmuRef in set dom I.scenario.connections.dataConnections
				and pre_derefInput(I.scenario.fmus(connectedInput.name), connectedInput.ref);

	-- This action obtains a value from an output		
	getPort : Importer * FMURef -> Importer
	getPort(I, port)==
		let mk_(fmu, val) = get_m(I.scenario.fmus(port.name), port.ref), 
		 	connectedInput = I.scenario.connections.dataConnections(port) in
			mu(I, 
				scenario |-> mu(I.scenario, fmus |-> I.scenario.fmus ++ {fmu.name |-> fmu}),
				valueMap |-> I.valueMap ++ {connectedInput |-> val}
			)
	pre pre_preGetI(I, I.scenario.fmus(port.name), port.ref) 
		and preGetI(I, I.scenario.fmus(port.name), port.ref)
		and pre_get_m(I.scenario.fmus(port.name), port.ref)
	post 
		card dom RESULT.valueMap = card dom I.valueMap + 1
		and
		let oldFMUs = rng ({port.name} <-: I.scenario.fmus),
			resultFMUs = rng ({port.name} <-: RESULT.scenario.fmus) in
			pre_fmusNotAffected(oldFMUs, resultFMUs)
			and fmusNotAffected(oldFMUs, resultFMUs);


	postVariableCalculation : FMURef * Importer * Importer -> bool
	postVariableCalculation(equation, I, NewI) ==
		equation in set NewI.calculatedEquations
		and I.relevantInputClocks = NewI.relevantInputClocks
		and I.relevantOutputClocks subset NewI.relevantOutputClocks
		and I.calculatedEquations subset  NewI.calculatedEquations
		and let fmu = NewI.scenario.fmus(equation.name) in
			pre_fmusNotAffected(rng ({fmu.name} <-: I.scenario.fmus), rng ({fmu.name} <-: NewI.scenario.fmus))
			and fmusNotAffected(rng ({fmu.name} <-: I.scenario.fmus), rng ({fmu.name} <-: NewI.scenario.fmus))
			and fmu.mode =  <EVENT>
	pre equation.name in set dom NewI.scenario.fmus;


	/*
	* Calculates an output equation that needs to be calculated.
	* The port is calculated by the getting its value
	*/
	calculateOutput : Importer * FMURef -> Importer
	calculateOutput(I, equation)==
		-- @Printf("Calculating  output equation : %s\n", equation)
		let I1 : Importer = getPort(I, equation) in
			updateEnvironmentEquation(I1, I.scenario.fmus(equation.name), equation)
	pre 
		let fmu : FMU = I.scenario.fmus(equation.name) in
		equation in set I.activeEquations \ I.calculatedEquations
		and fmu.mode = <EVENT>
		and pre_preGetI(I, fmu, equation.ref)
		and preGetI(I, fmu, equation.ref)
		and pre_getPort(I, equation)
		and pre_updateEnvironmentEquation(getPort(I, equation), I.scenario.fmus(equation.name), equation)
	post pre_postVariableCalculation(equation, I, RESULT)
	and postVariableCalculation(equation, I, RESULT);

    /*
        Asserts that all FMUs are in the same state/mode
     */
    assertFMUMode : set of FMU * set1 of FMUMode -> bool
    assertFMUMode(fmus, modes) ==
        exists1 mode in set modes &
            (forall fmu in set fmus & fmu.mode = mode)
	pre true;


	fmusSynchronized: set1 of FMU -> bool
	fmusSynchronized(fmus) ==
		 card { fmu.time | fmu in set fmus } = 1
	pre true;

	fmusSynchronizedAtTime: set1 of FMU * Time -> bool
	fmusSynchronizedAtTime(fmus, t) ==
		 fmusSynchronized(fmus)
		 	and forall fmu in set fmus & fmu.time = t
	pre pre_fmusSynchronized(fmus);


	preInitialization : Importer -> bool
	preInitialization(I) ==
	let fmus : set1 of FMU = rng I.scenario.fmus in
		pre_assertFMUMode(fmus, {<INIT>})
		and assertFMUMode(fmus, {<INIT>})
		and I.time = mk_Time(0,0)
		and pre_fmusSynchronizedAtTime(fmus, I.time)
		and fmusSynchronizedAtTime(fmus, I.time)
	pre true;
		


	-- This can probably be done inline
	filterOutputs : seq of FMU * set of PortType -> set of FMURef
	filterOutputs(fmus, variableTypes) ==
	if fmus = [] then {}
	else
	let fmu : FMU = hd fmus in
		{ mk_FMURef(fmu.name, outputVar.ref) | outputVar in set fmu.io.LFoutput 
											   & outputVar.type in set variableTypes}
											   union filterOutputs(tl fmus, variableTypes)
	pre fmus <> [] => pre_filterOutputs(tl fmus, variableTypes) 
	measure len fmus;


    -- All connections are synchronized meaning the input and output value is identical
    variablesSynchronized: Scenario * set1 of PortType -> bool
    variablesSynchronized(M, variableTypes) ==
		let outputs : set of FMURef = filterOutputs([fmu | fmu in set rng M.fmus], variableTypes) in
        forall srcPort in set outputs &
			srcPort in set dom M.connections.dataConnections and
            let trgPort : FMURef = M.connections.dataConnections(srcPort) in
            	(M.fmus(srcPort.name)).env(srcPort.ref) = (M.fmus(trgPort.name)).env(trgPort.ref)
	pre pre_filterOutputs([fmu | fmu in set rng M.fmus], variableTypes);


	postInitialization : Importer -> bool
	postInitialization(I) ==
	let fmus : set1 of FMU = rng I.scenario.fmus in
		pre_assertFMUMode(fmus, {<INIT>})
		and assertFMUMode(fmus, {<INIT>})
		and pre_fmusSynchronizedAtTime(fmus, I.time)
		and fmusSynchronizedAtTime(fmus, I.time)
		and I.time = mk_Time(0,0)
		and variablesSynchronized(I.scenario, {<continous>, <discrete>})
	pre pre_variablesSynchronized(I.scenario, {<continous>, <discrete>});
	

	preStepI: Importer * FMU -> bool
	preStepI(I, fmu) ==
		not exists m in set rng I.scenario.fmus 
								& m.name <> fmu.name and m.time < fmu.time
		and preStepT(fmu, I.stepSize)
	pre pre_preStepT(fmu, I.stepSize);

	ImporterNotAffected : Importer * Importer -> bool
	ImporterNotAffected(oldImporter, newImporter) == 
		oldImporter.activeClocks = newImporter.activeClocks
		and oldImporter.readyClocks = newImporter.readyClocks
		and oldImporter.inactiveClocks = newImporter.inactiveClocks
		and oldImporter.relevantOutputClocks = newImporter.relevantOutputClocks
		and oldImporter.relevantInputClocks = newImporter.relevantInputClocks
		and oldImporter.activeEquations = newImporter.activeEquations
		and oldImporter.calculatedEquations = newImporter.calculatedEquations
		and oldImporter.readyEquations = newImporter.readyEquations
		and oldImporter.endtime = newImporter.endtime
		and oldImporter.valueMap = newImporter.valueMap
	pre true;


	/*
	 * This action progresses an FMU in time
	 * It also keeps track of the FMUs that triggers an event and adjust the step size dynamically
	 */
	stepFMU : Importer * FMU -> Importer
	stepFMU(I, fmu)==
		let mk_(fmuUpdated, step, event) : FMU * Real1 * bool = step_tm(fmu, I.stepSize) in
			mu(I, 
				scenario |-> mu(I.scenario, fmus |-> I.scenario.fmus ++ {fmuUpdated.name |-> fmuUpdated}),
				fmusWithEvent |-> if event then I.fmusWithEvent union {fmu.name} else I.fmusWithEvent,
				stepSize |-> step -- adjust the stepsize 
			)
	pre 
		pre_preStepI(I, fmu) 
		and preStepI(I, fmu) 
		and pre_step_tm(fmu, I.stepSize)
	post 
		let resultFMUs = rng ({fmu.name} <-: RESULT.scenario.fmus),
			oldFMUs = rng ({fmu.name} <-: I.scenario.fmus) in
			pre_fmusNotAffected(oldFMUs, resultFMUs)
			and fmusNotAffected(oldFMUs, resultFMUs)
			and I.fmusWithEvent subset RESULT.fmusWithEvent
			and I.stepSize >= RESULT.stepSize
			and pre_ImporterNotAffected(I, RESULT)
			and ImporterNotAffected(I, RESULT);


	/*
	 * This function sets the activation status of the clock
	 */
	setClock : Importer * FMU * Ref * bool -> Importer
	setClock(I, fmu, clock, val)==
		let fmuUpdated : FMU = set_cm(fmu, clock, val),
			fmuref : FMURef = mk_FMURef(fmu.name, clock),
		    feedthroughClocks = {mk_FMURef(fmu.name, c.ref) | c in set fmu.clocks & clock in set c.dependsOn},
		I1 : Importer = mu(I,
			valueMap |-> {fmuref} <-: I.valueMap,
			relevantInputClocks |-> I.relevantInputClocks \ {fmuref}, -- remain the same
			relevantOutputClocks |-> I.relevantOutputClocks union feedthroughClocks -- Other clocks might have been activated
		) in
		updateEnvironmentClock(I1, fmuUpdated, clock, val)
	pre 
		pre_set_cm(fmu, clock, val)
		and
		let fmuRef : FMURef = mk_FMURef(fmu.name,clock) in 
			fmuRef in set I.relevantInputClocks -- a clock should be relevant if we should query it
			and (val <=> fmuRef in set I.inactiveClocks inter I.readyClocks)
			and fmu.mode = <EVENT>
	post 
		let fmuRef : FMURef = mk_FMURef(fmu.name,clock) in 
			fmuRef not in set RESULT.relevantInputClocks
			and card RESULT.relevantInputClocks < card I.relevantInputClocks
			and RESULT.scenario.fmus(fmu.name).mode = <EVENT>
			and (val <=> (fmuRef in set RESULT.activeClocks) and fmuRef not in set (RESULT.readyClocks union RESULT.inactiveClocks));



	preGetCI: Importer * FMU * Ref -> bool
	preGetCI(I, fmu, clock) ==
		let outputVar : FMURef = mk_FMURef(fmu.name, clock) in
			outputVar in set I.relevantOutputClocks
				and preGetC(fmu, clock)
	pre pre_preGetC(fmu, clock);

	preSetCI: Importer * FMU * Ref -> bool
	preSetCI(I, fmu, clock) ==
		let inputVar : FMURef = mk_FMURef(fmu.name, clock) in
			inputVar in set dom I.valueMap inter I.relevantInputClocks and
		let val : FMIValue = I.valueMap(inputVar) in
			pre_preSetC(fmu, clock, val.fmiValue)
			and preSetC(fmu, clock, val.fmiValue)
			and (val.fmiValue <=> (inputVar in set I.inactiveClocks inter I.readyClocks))
	pre true;

	/*
	 * Query a clock to check its activation status
	 */
	queryClock: Importer * FMU * Ref -> Importer
	queryClock(I, fmu, clock)==
		let mk_(fmuUpdated, val) = get_cm(fmu, clock),
			fmuref = mk_FMURef(fmu.name, clock),
		connectedClock = I.scenario.connections.clockConnections(fmuref),
		I1 : Importer = mu(I, 
			valueMap |-> I.valueMap ++ {connectedClock |-> val},
			relevantOutputClocks |-> I.relevantOutputClocks \ {fmuref},
			relevantInputClocks |-> I.relevantInputClocks union {connectedClock}
		) in
		updateEnvironmentClock(I1, fmuUpdated, clock, val.fmiValue)
	pre 
		mk_FMURef(fmu.name,clock) in set I.relevantOutputClocks -- a clock should be relevant if we should query it
		and clock in set {c.ref | c in set fmu.clocks & c.type = <output>}
		and pre_preGetCI(I, fmu, clock)
		and	preGetCI(I, fmu, clock)
		and pre_get_cm(fmu, clock)
		and 
			let mk_(fmuUpdated, val) = get_cm(fmu, clock),
				fmuref = mk_FMURef(fmu.name, clock),
				connectedClock = I.scenario.connections.clockConnections(fmuref),
			I1 : Importer = mu(I, 
				valueMap |-> I.valueMap ++ {connectedClock |-> val},
				relevantOutputClocks |-> I.relevantOutputClocks \ {fmuref},
				relevantInputClocks |-> I.relevantInputClocks union {connectedClock}
			) in
				pre_updateEnvironmentClock(I1, fmuUpdated, clock, val.fmiValue)
	post mk_FMURef(fmu.name,clock) not in set RESULT.relevantOutputClocks;
	
	/*
		Runs a single action
	*/
	runAction: Importer * Action -> Importer
	runAction(I, action)==
	let fmus : map Name to FMU = I.scenario.fmus,
		mk_Action(actionType, fmu, port) = action in
			cases actionType:
				<get> -> if fmus(fmu).mode = <EVENT> then calculateOutput(I, mk_FMURef(fmu, port)) else getPort(I, mk_FMURef(fmu, port)),
				<set> -> if fmus(fmu).mode = <EVENT> then calculateInput(I, mk_FMURef(fmu, port)) else setPort(I, mk_FMURef(fmu, port)),
				<step> -> stepFMU(I, I.scenario.fmus(fmu)),
				<setC> -> setClock(I, I.scenario.fmus(fmu), port, true),
				<get> -> queryClock(I, I.scenario.fmus(fmu), port),
				others -> I -- Default match
			end
	pre
		let fmus : map Name to FMU  = I.scenario.fmus,
			mk_Action(actionType, fmu, port) = action in
			cases actionType:
				<get> -> if fmus(fmu).mode = <EVENT> then pre_calculateOutput(I, mk_FMURef(fmu, port)) else pre_getPort(I, mk_FMURef(fmu, port)),
				<set> -> if fmus(fmu).mode = <EVENT> then pre_calculateInput(I, mk_FMURef(fmu, port)) else pre_setPort(I, mk_FMURef(fmu, port)),
				<step> -> pre_stepFMU(I, I.scenario.fmus(fmu)),
				<setC> -> pre_setClock(I, I.scenario.fmus(fmu), port, true),
				<get> -> pre_queryClock(I, I.scenario.fmus(fmu), port),
				others -> false -- Default match
			end;

	/*
	 * Is an Action activated?
	 * It is if the Importer think that its precondition is satisfied
	 */
	isActionEnabled : Importer * Action -> bool
	isActionEnabled(I, action) ==
		let mk_Action(actionType, fmu, port) = action in
			cases actionType:
				<get> -> pre_preGetI(I, I.scenario.fmus(fmu), port) and preGetI(I, I.scenario.fmus(fmu), port),
				<set> -> pre_preSetI(I, I.scenario.fmus(fmu), port) and preSetI(I, I.scenario.fmus(fmu), port),
				<step> -> pre_preStepI(I, I.scenario.fmus(fmu)) and preStepI(I, I.scenario.fmus(fmu)),
				<setC> -> pre_preSetCI(I, I.scenario.fmus(fmu), port) and preSetCI(I, I.scenario.fmus(fmu), port),
				<getC> -> pre_preGetCI(I, I.scenario.fmus(fmu), port) and preGetCI(I, I.scenario.fmus(fmu), port),
				others -> false --default Match
			end
	pre true;

	
	/*
		Function to run a set of actions (algorithm) until completion
		We pick an enabled action and perform it until the set of actions is empty
	*/
	runAlgorithm : Importer * seq of Action -> Importer
	runAlgorithm(I, algorithm)==
		--fold[Action](runAction, I, algorithm)
		if algorithm = [] then I
		else
		let action in set {action | action in seq algorithm 
							& pre_isActionEnabled(I, action) 
							and isActionEnabled(I, action)} 
		in
			--@Printf("Action to execute: %s\n", action)
			runAlgorithm(runAction(I, action), [act | act in set elems algorithm \ {action}])
	pre 
		algorithm <> [] => 
			let action 
				in set {action | action in set elems algorithm 
					& pre_isActionEnabled(I, action) 
					and isActionEnabled(I, action)} 
				in
					pre_runAction(I, action)
					and pre_runAlgorithm(runAction(I, action), [act | act in set elems algorithm \ {action}])
	measure len algorithm;

	exchangeActions: map FMURef to FMURef -> seq of Action
	exchangeActions(connections) ==
		let outputs : set of Action = {mk_Action(<get>, outputVar.name, outputVar.ref) | outputVar in set dom connections},
			inputs : set of Action = {mk_Action(<set>, inputVar.name, inputVar.ref) | inputVar in set rng connections},
			portsActions : set of Action = outputs union inputs in			
				[act | act in set portsActions]
	pre true
	post len(RESULT) = card dom connections + card rng connections;

	/*
		This function exchanges values between all connected Inputs and Outputs
		Currently we do not support algebraic loops
		It uses the runAlgorithm Function to execute the actions
	*/
	initializeData: Importer -> Importer
	initializeData(I) ==
	let actions : seq of Action = exchangeActions(I.scenario.connections.dataConnections) in
		runAlgorithm(I, actions)
	pre 
		pre_preInitialization(I) 
		and preInitialization(I) 
		and pre_exchangeActions(I.scenario.connections.dataConnections)
		and pre_runAlgorithm(I, exchangeActions(I.scenario.connections.dataConnections))
	post 
		pre_postInitialization(RESULT) 
		and postInitialization(RESULT);

	/*
		This function calculates the set of clocks that should be ticked
	*/
	tickingClocks: Importer -> Importer * set of FMURef
	tickingClocks(I) ==
		-- Clocks to tick at the current time
		let clocksTickingNow : set of Name = dom (I.schedule :> {I.time.r}),
		 	inputsToTick = dunion rng (clocksTickingNow <: I.scenario.connections.timedClockConnections),
			relevantTimeBasedClocks : set of TimeBasedClock = {clock | clock in set I.scenario.timeBasedClocks & clock.name in set clocksTickingNow},
			-- Update the schedule for the ticked clocks to a new point in time
		 	updatedSchedule : map Name to Real1 = {c.name |-> (c.period + I.time.r) | c in set relevantTimeBasedClocks},
			-- The clocks (input) are now relevant and their schedule is now updated
			I1 = mu(I, 
						relevantInputClocks |-> inputsToTick,
						schedule |-> I.schedule ++ updatedSchedule
			) in
			mk_(I1, inputsToTick)
	pre 
		true
	post
		(dom (I.schedule :> {I.time.r}) = {} <=> RESULT.#1 = I)
		and (dom (I.schedule :> {I.time.r}) <> {} <=> RESULT.#2 <> {});


	fmusToAdd : Scenario * set of Name * set of Name -> set of Name 
	fmusToAdd(M, addedFMUs, notAddedFMUS) ==
		{M.connections.clockConnections(con).name | con in set dom M.connections.clockConnections & con.name in set addedFMUs 
															and M.connections.clockConnections(con).name in set notAddedFMUS} 
	pre addedFMUs inter notAddedFMUS = {}
	post RESULT subset notAddedFMUS;

	/*
		This is the recurrence relation from the paper - calculating the set of FMUs that must enter Event mode.
		We added the FMUs that has a ticking clock 
		And subsequently include all FMUs that has clock connection from an FMU in the event Mode 
	*/ 
	calculateRelevantFMUs: Scenario * set of Name * set of Name -> set of Name 
	calculateRelevantFMUs(M, relevantFMUs, notRelevantFMUs) == 
		let addedFMUs : set of Name = fmusToAdd(M, relevantFMUs, notRelevantFMUs) in
		-- We terminate if we have reached a fixed point where no more relevant FMUs can be found
		if addedFMUs = {} then relevantFMUs
		else 
			calculateRelevantFMUs(M, relevantFMUs union addedFMUs, notRelevantFMUs \ addedFMUs)
		pre 
			relevantFMUs inter notRelevantFMUs = {}
			and relevantFMUs union notRelevantFMUs = dom M.fmus
			and pre_fmusToAdd(M, relevantFMUs, notRelevantFMUs)
			and 
				let addedFMUs : set of Name = fmusToAdd(M, relevantFMUs, notRelevantFMUs) in
					(addedFMUs <> {} => pre_calculateRelevantFMUs(M, relevantFMUs union addedFMUs, notRelevantFMUs \ addedFMUs))
		post 
			RESULT subset dom M.fmus
			and 
				let notAdded : set of Name = dom M.fmus \ RESULT in
					not exists srcClock in set dom M.connections.clockConnections & srcClock.name in set RESULT 
						and M.connections.clockConnections(srcClock).name in set notAdded
		measure card notRelevantFMUs;


	/*
		The precondition of the Co-simulation Step procedure
	*/
    preCoSimulationStep: Scenario * Time -> bool
    preCoSimulationStep(scenario, time) ==
        let fmus : set1 of FMU = rng scenario.fmus in
			pre_assertFMUMode(fmus, {<STEP>})
			and assertFMUMode(fmus, {<STEP>})
			and pre_variablesSynchronized(scenario, {<continous>})
			and variablesSynchronized(scenario, {<continous>}) 
			and pre_fmusSynchronizedAtTime(fmus, time)
			and fmusSynchronizedAtTime(fmus, time)
	pre true;


    /**
	 * Move all relevant FMUs into event mode.
	 */
	enterEventMode: Importer * set1 of Name -> Importer
	enterEventMode(I, fmus) ==
		mu(I, scenario |-> mu(I.scenario, 
		fmus |-> I.scenario.fmus ++
			{ name |->  mu(I.scenario.fmus(name), mode |-> <EVENT>) | name in set dom I.scenario.fmus inter fmus }))
	pre 
		pre_preCoSimulationStep(I.scenario, I.time)
		and preCoSimulationStep(I.scenario, I.time)
	post
		pre_ImporterNotAffected(I, RESULT)
		and ImporterNotAffected(I, RESULT)
		and pre_variablesSynchronized(RESULT.scenario, {<continous>})
		and variablesSynchronized(RESULT.scenario, {<continous>})
		and let fmusAffected  : set of FMU = rng (fmus <: RESULT.scenario.fmus) in
			pre_assertFMUMode(fmusAffected, {<EVENT>})
			and assertFMUMode(fmusAffected, {<EVENT>})
	 		and forall m' in set fmusAffected & m'.time.i = 0;


	postStepMode : Importer * Importer * set1 of Name -> bool
	postStepMode(I, oldImporter, fmus) ==
		ImporterNotAffected(oldImporter, I)
		and preCoSimulationStep(I.scenario, I.time)
		and fmusNotAffected(rng (fmus <-: I.scenario.fmus), rng (fmus <-: oldImporter.scenario.fmus))
		and let relevantFMUs : set of FMU = rng (fmus <: I.scenario.fmus) in
			assertFMUMode(relevantFMUs, {<STEP>})
	pre 
		pre_ImporterNotAffected(oldImporter, I)
		and pre_preCoSimulationStep(I.scenario, I.time)
		and pre_fmusNotAffected(rng (fmus <-: I.scenario.fmus), rng (fmus <-: oldImporter.scenario.fmus))
		and let relevantFMUs : set of FMU = rng (fmus <: I.scenario.fmus) in
			pre_assertFMUMode(relevantFMUs, {<STEP>});	

    /**
	 * Move all FMUs in M into Step mode.
	 */
	enterStepMode: Importer * set1 of Name -> Importer
	enterStepMode(I, fmus) ==
		mu(I, 
			scenario |-> mu(
							I.scenario, 
							fmus |-> I.scenario.fmus ++ { name |-> mu(I.scenario.fmus(name), mode |-> <STEP>, time |-> mk_Time(I.scenario.fmus(name).time.r, 0)) | name in set fmus }),
							time |-> mk_Time(I.time.r, 0)
			)
	pre
		pre_variablesSynchronized(I.scenario, {<continous>}) 
		and variablesSynchronized(I.scenario, {<continous>})
		and 
		let relevantFMUs : set1 of FMU = rng (fmus <: I.scenario.fmus) in
			pre_assertFMUMode(relevantFMUs, {<INIT>, <EVENT>})
			and assertFMUMode(relevantFMUs, {<INIT>, <EVENT>})
			and pre_fmusSynchronized(relevantFMUs)
			and fmusSynchronized(relevantFMUs)
	post 
		pre_postStepMode(RESULT, I, fmus)
		and postStepMode(RESULT, I, fmus);


	preEventMode : Importer * set of FMURef  -> bool
	preEventMode(I, clocks) ==
		preCoSimulationStep(I.scenario, I.time)
			and (I.fmusWithEvent union clocks <> {}) -- An event is active
	pre 
		pre_preCoSimulationStep(I.scenario, I.time);

	postEventMode : Importer -> bool 
	postEventMode(I) ==
		preCoSimulationStep(I.scenario, I.time)
			and I.fmusWithEvent = {}
	pre 
		pre_preCoSimulationStep(I.scenario, I.time);


	/**
	 * Activate the clocks in all FMUs that are due to tick at this time.
	 * All clocks should be input clocks
	 */
	activateClocks: Importer * seq of FMURef -> Importer 
	activateClocks(I, clocks) ==
		if clocks = [] then I
		else 
		let clock : FMURef = hd clocks,
			I1 : Importer = setClock(I, I.scenario.fmus(clock.name), clock.ref, true) in
				activateClocks(I1, tl clocks)		
	pre 
		let clockSet : set of FMURef = elems clocks 
		in
			clockSet subset I.readyClocks inter I.relevantInputClocks
		and let fmusOfClocks : set of FMU = 
			{I.scenario.fmus(clock.name) | clock in set clockSet & clock.name in set dom I.scenario.fmus} 
		in
			pre_assertFMUMode(fmusOfClocks, {<EVENT>})
			and assertFMUMode(fmusOfClocks, {<EVENT>})
		and (clocks <> [] => 
				let clock = hd clocks in
					clock.name in set dom I.scenario.fmus
					and pre_setClock(I, I.scenario.fmus(clock.name), clock.ref, true)
					and let I1 = setClock(I, I.scenario.fmus(clock.name), clock.ref, true)
						in pre_activateClocks(I1, tl clocks) 
			)
	post 
		let clockSet : set of FMURef = elems clocks in
			clockSet subset RESULT.activeClocks
		and (clockSet <> {} => not clockSet subset RESULT.readyClocks)
		and (clockSet <> {} => not clockSet subset RESULT.relevantInputClocks)
		and let fmusOfClocks = {RESULT.scenario.fmus(clock.name) | clock in set clockSet} in
			pre_assertFMUMode(fmusOfClocks, {<EVENT>})	
			and assertFMUMode(fmusOfClocks, {<EVENT>})
	measure len clocks;
	

eventClockActions : set of FMURef * set of FMURef -> set of Action
eventClockActions(relevantInputClocks, relevantOutputClocks) ==
	 	let queryClockActions : set of Action = { mk_Action(<getC>, clock.name, clock.ref) | clock in set relevantOutputClocks }, 
			setClockActions : set of Action = { mk_Action(<setC>, clock.name, clock.ref) | clock in set relevantInputClocks } in
			queryClockActions union setClockActions
pre relevantInputClocks inter relevantOutputClocks = {}
post card RESULT = card relevantInputClocks + card relevantOutputClocks;


/*
* This function finds an appropiate action to solve the active event.
* It pick a clockAction (setC or getC) if it is possible otherwise it selects a regular port action.
*/
selectAction : Importer -> Action
selectAction(I) ==
	let fmus : map Name to FMU = I.scenario.fmus,
		clockActions : set of Action = eventClockActions(I.relevantInputClocks, I.relevantOutputClocks),
		enableClockActions : set of Action = {action | action in set clockActions & pre_isActionEnabled(I, action) and isActionEnabled(I, action)} in
			if enableClockActions <> {} 
			then
				let clockAction in set enableClockActions in
					clockAction
			else
				let portActions : set of Action = {mk_Action(<set>, inputRef.name, inputRef.ref) | inputRef in set (I.activeEquations \ I.calculatedEquations) 
																			& inputRef.ref in set {inputVar.ref | inputVar in set fmus(inputRef.name).io.LFinput}}
								union {mk_Action(<get>, outputRef.name, outputRef.ref) | outputRef in set I.activeEquations \ I.calculatedEquations 
																			& outputRef.ref in set {outputVar.ref | outputVar in set fmus(outputRef.name).io.LFoutput} } in
				let portAction in set {action | action in set portActions & pre_isActionEnabled(I, action) and isActionEnabled(I, action)} in
				portAction
	pre I.activeEquations \ I.calculatedEquations <> {}
		and pre_eventClockActions(I.relevantInputClocks, I.relevantOutputClocks) 
	post 
		RESULT.actionType <> <step> 
		and
		-- I will always select a clock action if it is possible
		(RESULT.actionType in set {<getC>, <setC>} => (I.relevantOutputClocks union I.relevantInputClocks) <> {})
		and (RESULT.actionType not in set {<getC>, <setC>} => (I.relevantOutputClocks union I.relevantInputClocks) = {});


	/*
	* This function solves the active events by solving the system of equations
	* It terminates when all active variables have been calculated
	* Clock actions should also be performed before regular port actions.
	*/
	solveSystemOfEquations : Importer -> Importer
	solveSystemOfEquations(I) ==
		if I.activeEquations \ I.calculatedEquations = {} then I
		else
		let action : Action = selectAction(I)
			in solveSystemOfEquations(runAction(I, action))
	pre 
		(I.activeEquations \ I.calculatedEquations <> {}) => 	
			pre_selectAction(I) 
			and let action : Action = selectAction(I) in
				pre_runAction(I, action)
				and pre_solveSystemOfEquations(runAction(I, action))
	post 
		RESULT.activeEquations \ RESULT.calculatedEquations = {}
	measure card I.readyEquations + card (I.activeEquations \ I.calculatedEquations);

    timeAdvanced: set1 of FMU * set1 of FMU * bool -> bool
    timeAdvanced(newFMUs, oldFMUs, discreteTime) ==
        (forall m' in set newFMUs &
            (exists1 m in set oldFMUs & m.name = m'.name 
				and m.time <= m'.time -- The FMU is advanced in time
				and (discreteTime => (m.time.i + 1 = m'.time.i and m.time.r = m'.time.r))
				and (not discreteTime => (m.time.i = m'.time.i and m.time.r <= m'.time.r))))
	pre 
		pre_sameSetOfFMUs(newFMUs, oldFMUs)
		and sameSetOfFMUs(newFMUs, oldFMUs);


    eventSolved : Importer * set1 of FMU * set1 of FMU -> bool
    eventSolved(I, newFmus, oldFmus) ==
            assertFMUMode(newFmus, {<EVENT>})
            and timeAdvanced(newFmus, oldFmus, true)
            and I.activeEquations \ I.calculatedEquations = {} -- Event solved
            and I.relevantInputClocks union I.relevantOutputClocks = {} -- no more clocks to activate
        pre 
			pre_timeAdvanced(newFmus, oldFmus, true)
			and pre_assertFMUMode(newFmus, {<EVENT>})
			and pre_sameSetOfFMUs(newFmus, oldFmus)
			and sameSetOfFMUs(newFmus, oldFmus);



	/**
	 * Update the discrete state of all FMUs.
	 */
	updateDiscreteState: Importer * set1 of Name -> Importer
	updateDiscreteState(I,fmus) ==
		let M : Scenario = I.scenario,
			res : map Name to (FMU * bool) = {fmu |-> step_e(M.fmus(fmu)) | fmu in set fmus},
			fmuMap : map Name to FMU = I.scenario.fmus ++ { fmu |-> res(fmu).#1 | fmu in set dom res}, 
			eventFMUs : set of Name = { fmu | fmu in set dom res & res(fmu).#2 = true} -- fmus that triggered an event
		in
		mu(I, 
			scenario |-> mu(I.scenario, fmus |-> fmuMap),
			fmusWithEvent |-> eventFMUs,
			activeClocks |-> {},
			inactiveClocks |-> I.inactiveClocks union I.activeClocks,
			activeEquations |-> {},
			readyClocks |-> I.inactiveClocks union I.activeClocks,
			readyEquations |->  I.readyEquations union I.calculatedEquations union I.activeEquations,
			calculatedEquations |-> {},
			activeEquations |-> {}
		)
	pre
		fmus subset dom I.scenario.fmus
		and {pre_step_e(I.scenario.fmus(fmu)) | fmu in set fmus} = {true}
		and let relevantFMUs : set1 of FMU = rng (fmus  <: I.scenario.fmus) in
				pre_assertFMUMode(relevantFMUs, {<EVENT>})
				and assertFMUMode(relevantFMUs, {<EVENT>})
				and pre_fmusSynchronized(relevantFMUs)
				and fmusSynchronized(relevantFMUs)
	post 
		let newFmus : set1 of FMU = rng (fmus  <: RESULT.scenario.fmus),
			oldFMUs : set1 of FMU = rng (fmus  <: I.scenario.fmus)
		in
			pre_assertFMUMode(newFmus, {<EVENT>})
			and assertFMUMode(newFmus, {<EVENT>})
			and pre_fmusSynchronized(newFmus)
			and fmusSynchronized(newFmus)
			and pre_timeAdvanced(newFmus, oldFMUs, true)
			and timeAdvanced(newFmus, oldFMUs, true);

eventIteration : Importer * set of Name -> Importer
eventIteration(I, relevantFMUs)==
		/**
		* 3. Construct and solve system of equations for t.i :
		* 		(a) For all ycm in set Ycm of any instance m in set M, forward activation state of
		*		    triggered clocks:
		* 			i. Invoke get_cm (_, ycm ), and set_cm(_, ucm0 ) or get_cm (_, ycm0 ),
		*			   for any other clock ucm0 in set Ucm or ycm0 in set Ycm and instance
		*			   m in set M that is transitively connected to ycm or has become active
		*			   as a result of the clock activations;
		*		(b) Invoke get_m(_, ym0) and set_m(_, um0, _) in the appropriate order,
		*		    for any instance m in set M.
		*/

		let I1 : Importer = solveSystemOfEquations(I),
		-- @Printf("Event Solved\n")

		/**
		* 4. Invoke step_e(_) for m in set M (signals end of Event iteration t.i).
		*/
		-- @Printf("Updating the discrete state of %s\n", relevantFMUs)
			I2 : Importer = updateDiscreteState(I1, relevantFMUs) in
			I2
		/**
			* 5. Schedule clocks by invoking next_tm on every relevant clock, for m in set M.
		*/
		--updateSchedule(I2, relevantFMUs, { <tunable>, <changing>, <countdown> })
	pre 
		pre_solveSystemOfEquations(I)
		and pre_updateDiscreteState(solveSystemOfEquations(I), relevantFMUs)
		and
		let fmus : set of FMU = rng (relevantFMUs <: I.scenario.fmus) in
			pre_fmusSynchronized(fmus)
			and fmusSynchronized(fmus)
			and pre_assertFMUMode(fmus, {<EVENT>})
			and assertFMUMode(fmus, {<EVENT>})
	post 
		let newfmus : set of FMU = rng (relevantFMUs <: RESULT.scenario.fmus),
			oldfmus : set of FMU = rng (relevantFMUs <: I.scenario.fmus)
		in 
			pre_eventSolved(RESULT, newfmus, oldfmus)
			and eventSolved(RESULT, newfmus, oldfmus);


	/*
		Calculate a schedule for all timebased clocks
	*/
	createSchedule : Importer -> Importer
	createSchedule(I) == 
		let timedBasedClocks : set of TimeBasedClock = I.scenario.timeBasedClocks in 
			mu(I, 
				schedule |->  {c.name |-> c.period + c.shift | c in set timedBasedClocks}
			)
	pre 
		let fmus : set1 of FMU = rng I.scenario.fmus in
			pre_assertFMUMode(fmus, {<INIT>})
			and assertFMUMode(fmus, {<INIT>})
			and pre_fmusSynchronized(fmus)
			and fmusSynchronized(fmus)
			and pre_variablesSynchronized(I.scenario, {<discrete>, <continous>}) 
			and variablesSynchronized(I.scenario, {<discrete>, <continous>})
	post 
		let fmus : set1 of FMU = rng RESULT.scenario.fmus in
			dom RESULT.schedule = {c.name | c in set RESULT.scenario.timeBasedClocks}
			and pre_assertFMUMode(fmus, {<INIT>})
			and assertFMUMode(fmus, {<INIT>})
			and pre_fmusSynchronized(fmus)
			and fmusSynchronized(fmus)
			and pre_ImporterNotAffected(I, RESULT)
			and ImporterNotAffected(I, RESULT)
			and pre_variablesSynchronized(RESULT.scenario, {<discrete>, <continous>})
			and variablesSynchronized(RESULT.scenario, {<discrete>, <continous>});


	calculateSchedule: FMU * set of Ref -> map FMURef to Real1
	calculateSchedule(fmu, clocks)== 
		{ mk_FMURef(fmu.name, clock) |-> next_tm(fmu, clock) | clock in set clocks }
	pre 
		(forall clock in set clocks & pre_next_tm(fmu, clock))
		and clocks subset {c.ref | c in set fmu.clocks & c.type = <input> and c.interval <> <triggered> }
	post card dom RESULT = card clocks;

/*
	This function updates the schedule
updateSchedule: Importer * set of Name * set of Interval -> Importer
updateSchedule(I, fmus, intervalSet)==
	if fmus = {} then I 
	else
	let name in set fmus in
		let fmu = I.scenario.fmus(name) in
			let relevantClocks = {c.ref | c in set fmu.clocks & c.interval in set intervalSet} in  
				let scheduleEntries = calculateSchedule(fmu, relevantClocks) in
					let I1 = mu(I, schedule |-> I.schedule ++ scheduleEntries) in
						updateSchedule(I1, fmus \ {name}, intervalSet)
measure card fmus;
*/

	/**
	* Let M denote the set of FMU instances participating in the simulation. We
	* assume that one FMU instance m in set M or the importer has requested to enter
	* Event mode. Therefore we assume that every other instance m' in set M and m' <> m
	* has been stepped up to the same super-dense time (t.r, 0).
	*/
	clockedSimulationAlgorithm: Importer * set of FMURef -> Importer
	clockedSimulationAlgorithm(I, activeClocks) ==
		/**
		* 1. Every m in set M enters Event mode (super-dense time instant is t.i = 0);
		*/
			-- @Printf("The following FMUs have triggered an event : %s\n", I.fmusWithEvent)
		let eventFMUs : set1 of Name = I.fmusWithEvent union {clock.name | clock in set activeClocks},
			relevantFMUs : set of Name = calculateRelevantFMUs(I.scenario, eventFMUs, (dom I.scenario.fmus) \ eventFMUs),
			I1 : Importer = enterEventMode(I, relevantFMUs),
		-- @Printf("The following FMUs are in Event mode : %s\n", relevantFMUs)

		/**
		* 2. Activate any time-based clocks scheduled to tick at (t.r , 0), by
		*    invoking set_cm(_, wcm0) for any input or output clock wcm0 in set
		*    Ucm union Ycm and any instance m in set M;
		*/
		-- @Printf("Ticking the clocks : %s\n", activeClocks)
			I2 : Importer = activateClocks(I1, [clock | clock in set activeClocks]),
		/*
			The event Iteration solves the system of equations, updates the schedule and the discrete state of the FMUs
		*/
			I3 : Importer = eventIteration(I2, relevantFMUs) in

				/**
				* 6. If any m in set M wishes to repeat the event iteration, or if a clock returned a
				*    zero interval, go to Step 3 (start iteration t.i + 1).
				*/

				if I3.fmusWithEvent = {} 
				then 
					-- @Printf("The following FMUs are now back in Step mode : %s\n", relevantFMUs)
					enterStepMode(I3, relevantFMUs)
				else clockedSimulationAlgorithm(I, activeClocks)
	pre 
		pre_preEventMode(I, activeClocks)
		and preEventMode(I, activeClocks)
		and let eventFMUs : set1 of Name = I.fmusWithEvent union {clock.name | clock in set activeClocks},
				notAddedFMUS : set of Name = (dom I.scenario.fmus) \ eventFMUs
			in
			 	pre_calculateRelevantFMUs(I.scenario, eventFMUs, notAddedFMUS)
			and
			let	relevantFMUs : set of Name = calculateRelevantFMUs(I.scenario, eventFMUs, notAddedFMUS) 
			in
				pre_enterEventMode(I, relevantFMUs)
				and 
				let I1 : Importer = enterEventMode(I, relevantFMUs)
				in
					pre_activateClocks(I1, [clock | clock in set activeClocks])
				and
				let I2 : Importer = activateClocks(I1, [clock | clock in set activeClocks])
				in 
					pre_eventIteration(I2, relevantFMUs)
				and
				let I3 : Importer = eventIteration(I2, relevantFMUs)
				in 
					I3.fmusWithEvent <> {} => pre_clockedSimulationAlgorithm(I3, activeClocks)
					and I3.fmusWithEvent = {} => pre_enterStepMode(I3, relevantFMUs)
	post 
		pre_postEventMode(RESULT)
		and postEventMode(RESULT)
	-- I do not know the measure - it has something to do with the events that FMUs trigger
	measure is not yet specified;



	minset : set of Real1 * Real1 -> Real1
	minset(s, leomin) ==
	if s = {} 
	then leomin
	else 
		let e in set s in
		let new_set : set of Real1 = s \ {e}
		in 
			if e < leomin 
			then 
				minset(new_set, e)
			else 
				minset(new_set, leomin)
	pre 
		s <> {} => 
			let e in set s in
			let new_set : set of Real1 = s \ {e}
			in
				pre_minset(new_set, e)
	post 
		forall elem in set s & elem >= RESULT
	measure card s;

	-- maxs_nat_isa: set of @T -> @T
	-- maxs_nat_isa(s) == fold[nat]((lambda x: int, y: int & max(x,y)), 0, set2seq[int](s))
	-- post
	-- 	forall x in set s & x <= RESULT;

	-- --@doc max of a set, default as maximum within the set, which will zero if empty
	-- mins_nat: set of nat -> nat
	-- mins_nat(s) == if s = {} then 0 else mins(s)
	-- post
	-- 	forall x in set s & RESULT <= x;

	-- mins_nat_isa: set of nat -> nat
	-- mins_nat_isa(s) == fold[nat]((lambda x: int, y: int & min(x,y)), maxs_nat_isa(s), set2seq[int](s))
	-- post
	-- 	forall x in set s & RESULT <= x;

	-- use fold instead
	selectMinStep : set1 of Real1 -> Real1
	selectMinStep(steps) == minset(steps, 10000)
	pre pre_minset(steps, 10000)
	post forall elem in set steps & elem >= RESULT;


	/*
	 * This is the initialization procedure that makes the scenario ready for simulation
	 */
    initialization: Importer -> Importer 
    initialization(I) ==
        -- We don't care about parameters of the FMU, they are ignored
        /**
         * Exchange data between all connections in M
        */
        let I1 : Importer = initializeData(I) in
        /**
         * Calculate a schedule for all timebased clocks
        */
        let I2 : Importer = createSchedule(I1) in
        /*
            Move all FMUs to Step Mode
         */
		-- @Printf("Initialization done\n")
        enterStepMode(I2, dom I2.scenario.fmus)
	pre 
		pre_preInitialization(I)
		and preInitialization(I)
		and pre_initializeData(I)
		and 
		let I1 : Importer = initializeData(I) in
			pre_createSchedule(I1)
			and 
			let I2 = createSchedule(I1) in
				pre_enterStepMode(I2, dom I2.scenario.fmus)
    post 
		pre_preCoSimulationStep(RESULT.scenario, RESULT.time)
		and preCoSimulationStep(RESULT.scenario, RESULT.time)
		and pre_ImporterNotAffected(RESULT, I) 
		and ImporterNotAffected(RESULT, I)
		and RESULT.time = mk_Time(0,0);


	postCosimulationStep: Scenario * set1 of FMU -> bool
    postCosimulationStep(scenario, oldFMUs) ==
		let fmus : set1 of FMU = rng scenario.fmus in
			assertFMUMode(fmus, {<STEP>}) 
                and variablesSynchronized(scenario, {<continous>}) 
                and fmusSynchronized(fmus)
                and timeAdvanced(fmus, oldFMUs, false)
	pre 
		pre_variablesSynchronized(scenario, {<continous>}) 
		and	let fmus : set1 of FMU = rng scenario.fmus in
				pre_assertFMUMode(fmus, {<STEP>}) 
				and pre_fmusSynchronized(fmus)
				and pre_timeAdvanced(fmus, oldFMUs, false);


	cosimStepActions: Connections * map Name to FMU -> seq1 of Action 
	cosimStepActions(connections, fmus) ==
		/* 
			1. Calculate all the actions that should be performed in the co-simulation step
			*/
		let outputs : set1 of Action = { mk_Action(<get>, outputVar.name, outputVar.ref) | outputVar in set dom connections 
																	& outputVar.name in set dom fmus 
																	and pre_derefOutput(fmus(outputVar.name), outputVar.ref) 
																	and derefOutput(fmus(outputVar.name), outputVar.ref).type = <continous>},
			inputs : set1 of Action = { mk_Action(<set>, inputVar.name, inputVar.ref) | inputVar in set rng connections 
																	& inputVar.name in set dom fmus 
																	and pre_derefInput(fmus(inputVar.name), inputVar.ref) 
																	and derefInput(fmus(inputVar.name), inputVar.ref).type = <continous>},
			steps : set1 of Action = { mk_Action(<step>, fmu.name, 1) | fmu in set rng fmus} in
		let actions : seq1 of Action = [act | act in set outputs union inputs union steps] in
			actions
	pre 
		{fmuRef.name | fmuRef in set dom connections} subset dom fmus
		and {fmuRef.name | fmuRef in set rng connections} subset dom fmus
	post
		len RESULT = card dom connections + card rng connections  + card dom fmus;


	/*
		This function runs a co-simulation step after the step negotiation
		Currently we do not support algebraic loops
		It uses the runAlgorithm-function to execute the actions
	*/
    cosimStep: Importer -> Importer
    cosimStep(I) ==
		/* 
			1. Calculate all the actions that should be performed in the co-simulation step
			2. Execute the actions in a correct ordeer.
		*/
		let actions : seq1 of Action = cosimStepActions(I.scenario.connections.dataConnections, I.scenario.fmus) in
			runAlgorithm(I, actions)
	pre 
		pre_preCoSimulationStep(I.scenario, I.time)
		and preCoSimulationStep(I.scenario, I.time)
		and pre_cosimStepActions(I.scenario.connections.dataConnections, I.scenario.fmus)
		and 
			pre_runAlgorithm(I,  cosimStepActions(I.scenario.connections.dataConnections, I.scenario.fmus)) 
		post 
			pre_postCosimulationStep(RESULT.scenario, rng I.scenario.fmus)
			and postCosimulationStep(RESULT.scenario, rng I.scenario.fmus);

	preTermination : Importer -> bool
	preTermination(I) ==
		preCoSimulationStep(I.scenario, I.endtime)
		and I.time.r = I.endtime.r
		and I.fmusWithEvent = {}
	pre pre_preCoSimulationStep(I.scenario, I.endtime);


	postTermination : Importer * Importer -> bool
	postTermination(I, oldI) ==
		assertFMUMode(rng I.scenario.fmus, {<DONE>})
			and fmusSynchronized(rng I.scenario.fmus)
			and ImporterNotAffected(oldI, I)
	pre 
		pre_assertFMUMode(rng I.scenario.fmus, {<DONE>})
			and pre_fmusSynchronized(rng I.scenario.fmus)
			and pre_ImporterNotAffected(oldI, I);

	terminate : Importer -> Importer
	terminate(I) ==
		mu(I, scenario |-> mu(I.scenario, fmus |-> { name |-> mu(I.scenario.fmus(name), mode |-> <DONE>) | name in set dom I.scenario.fmus }))
	pre
		pre_preTermination(I) 
		and preTermination(I)
	post 
		pre_postTermination(RESULT, I)
		and postTermination(RESULT, I);

    -- Calculate an appropiate step duration that all FMUs can take
	-- This should be done dynamically
    stepNegotiation: Importer -> Real1
    stepNegotiation(I) ==
		let maxSteps : set1 of Real1 = {fmu.maxStep | fmu in set rng I.scenario.fmus},
		 	scheduling : set of Real1 = {t - I.time.r | t in set rng I.schedule},
			timeLeft : Real1 = I.endtime.r - I.time.r,
			steps : set1 of Real1 = maxSteps union scheduling union {timeLeft} 
		in
			selectMinStep(steps)
	pre 
		let maxSteps : set1 of Real1 = {fmu.maxStep | fmu in set rng I.scenario.fmus},
		 	scheduling : set of Real1 = {t - I.time.r | t in set rng I.schedule},
			timeLeft : Real1 = I.endtime.r - I.time.r,
			steps : set1 of Real1 = maxSteps union scheduling union {timeLeft} 
		in
			pre_selectMinStep(steps)
	post (forall fmu in set rng I.scenario.fmus & fmu.maxStep >= RESULT) -- We ensure that the step is allowed
			and (forall clockTicks in set rng I.schedule & (clockTicks - I.time.r) >= RESULT) -- We do not miss a clock tick
			and RESULT <= I.stepSize -- We do not find a step larger than we want to take
			and RESULT <= I.endtime.r - I.time.r; -- We should not select a


	checkHandleEvents : Importer -> Importer
	checkHandleEvents(I) ==
        let mk_(I1, clocksToTick) : Importer * set of FMURef = tickingClocks(I),
		-- We should enter event mode if any clocks have ticked or any fmu wants to enter Event mode
			eventDetected : bool = clocksToTick <> {} or I1.fmusWithEvent <> {},
        /*
            If any events are present we solve them
        */
			I2 : Importer = (if eventDetected then clockedSimulationAlgorithm(I1, clocksToTick) else I) 
			
			in I2

	pre 
		pre_tickingClocks(I)
		and
			let mk_(I1, clocksToTick) : Importer * set of FMURef = tickingClocks(I),
			-- We should enter event mode if any clocks have ticked or any fmu wants to enter Event mode
				eventDetected : bool = clocksToTick <> {} or I1.fmusWithEvent <> {} 
			in
				(eventDetected => pre_clockedSimulationAlgorithm(I1, clocksToTick))
	post 
		pre_tickingClocks(I)
		and
			let mk_(I1, clocksToTick) : Importer * set of FMURef = tickingClocks(I),
			-- We should enter event mode if any clocks have ticked or any fmu wants to enter Event mode
				eventDetected : bool = clocksToTick <> {} or I1.fmusWithEvent <> {} 
			in
				(eventDetected <=> RESULT <> I);
		
	updateScenarioAfterStep : Importer -> Importer
	updateScenarioAfterStep(I) ==
		let fmus : map Name to FMU = I.scenario.fmus 
		in
			mu(I, 
				scenario |-> 
					mu(I.scenario, 
						fmus |-> { name |-> mu(fmus(name), stepped |-> false) | name in set dom fmus }),
						time |-> mk_Time(I.time.r + I.stepSize, I.time.i)
			)
	pre 
		--All fmus are stepped
		forall fmu in set rng I.scenario.fmus & fmu.stepped
	post
		I.time.r + I.stepSize = RESULT.time.r
		and forall fmu in set rng RESULT.scenario.fmus & not fmu.stepped;


	/*
	 * This is the co-simulation step procedure that moves the scenario from time "t" to time "t+H"
	 */
    cosimulationStep: Importer -> Importer 
    cosimulationStep(I) ==
        /*
            Detect events at the initial time
			And handle them
        */
		let I1 : Importer = checkHandleEvents(I),
        /*
            Select a step duration using step negotiation
         */
			I2 : Importer = mu(I1, stepSize |-> stepNegotiation(I1)),
        /*
            Perform the rest of the simulation
        */
			I3 : Importer = cosimStep(I2),
		-- @Printf("Cosimulation Step performed\n")
			I4 : Importer = updateScenarioAfterStep(I3)
			in
				if I4.endtime > I4.time 
				then 
					-- @Printf("We run an extra iteration of the co-simulation step\n")
					cosimulationStep(I4) 
				else I4
	pre 
		pre_preCoSimulationStep(I.scenario, I.time)
		and preCoSimulationStep(I.scenario, I.time)
		and pre_checkHandleEvents(I)
		and		
			let I1 : Importer = checkHandleEvents(I)
			in
				pre_stepNegotiation(I1)
			and
				let I2 : Importer = mu(I1, stepSize |-> stepNegotiation(I1))
				in 
					pre_cosimStep(I2)
				and 
					let I3 : Importer = cosimStep(I2)
					in pre_updateScenarioAfterStep(I3)
					and 
						let I4 : Importer = updateScenarioAfterStep(I3) 
						in 
							(I4.endtime > I4.time => pre_cosimulationStep(I4))
    post 
		pre_preCoSimulationStep(RESULT.scenario, RESULT.time)  
		and preCoSimulationStep(RESULT.scenario, RESULT.time) 
		and I.time.r <= RESULT.time.r
		and	pre_ImporterNotAffected(I, RESULT)	
		and	ImporterNotAffected(I, RESULT)
		and 
		let M' : set1 of FMU = rng RESULT.scenario.fmus,
			M  : set1 of FMU = rng I.scenario.fmus in
			pre_timeAdvanced(M', M, false)
         	and timeAdvanced(M', M, false)
	measure I.endtime.r - I.time.r;


	createImporter : Scenario * Real1 * Real1 -> Importer
	createImporter(M, endtime, stepSize) ==
	let clocks : set of FMURef = 
			dunion {createFMURefs(fmu, {c.ref | c in set fmu.clocks}) 
						| fmu in set rng M.fmus 
							& pre_createFMURefs(fmu, {c.ref | c in set fmu.clocks})},  

		discreteVariables : set of FMURef = 
			dunion {createFMURefs(fmu, {v.ref | v in set (fmu.io.LFinput union fmu.io.LFoutput) & v.type = <discrete>}) 
									| fmu in set rng M.fmus
										& pre_createFMURefs(fmu, {v.ref | v in set (fmu.io.LFinput union fmu.io.LFoutput) & v.type = <discrete>})}
	in
		mk_Importer(
			M,
			{|->},
			{},
			clocks,
			clocks,
			{},
			{},
			{},
			{},
			{},
			discreteVariables,
			mk_Time(0,0),
			mk_Time(endtime, 0),
			stepSize,
			{|->}
		)
	pre true;


	runScenario: Scenario -> Importer
	runScenario(scenario) ==
		let I : Importer = createImporter(scenario, 10, 5), 
			I_initialed : Importer = initialization(I),
			I2 : Importer = cosimulationStep(I_initialed) in
		terminate(I2)
	pre 
		pre_createImporter(scenario, 10, 5)
		and 
			let I : Importer = createImporter(scenario, 10, 5)
			in pre_initialization(I)
			and 
				let I_initialed : Importer = initialization(I)
				in pre_cosimulationStep(I_initialed) 
				and 
				let I2 : Importer = cosimulationStep(I_initialed) in
				pre_terminate(I2);

end Clocks